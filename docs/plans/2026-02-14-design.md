# astro-loader-glob-frontmatter — Design

## Problem

Astro content collections require frontmatter in every markdown file. For documentation sites with dozens or hundreds of pages, this means duplicating structured metadata (titles, descriptions, sidebar ordering) inside every `.md` file. This is tedious to maintain, hard to review in aggregate, and pollutes content files with framework-specific config.

## Solution

A custom Astro content loader that wraps `glob()` and injects frontmatter from external sources — either a single centralized file, per-directory files sitting next to the markdown, or both.

## Package

**Name**: `astro-loader-glob-frontmatter`

**Runtime**: Node.js (Astro content loader — runs at build time and dev server startup)

**Dependencies**: `yaml` (YAML parsing), `astro` (peer — uses `glob` from `astro/loaders`)

## Public API

```ts
import { defineCollection } from 'astro:content'
import { globFrontmatter } from 'astro-loader-glob-frontmatter'

const docs = defineCollection({
  loader: globFrontmatter({
    pattern: '**/*.md',
    base: './docs',
    frontmatter: './frontmatter.yml',  // optional centralized file
    strategy: 'file-wins',             // optional, default
  }),
  schema: z.object({ title: z.string() }),
})
```

### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `pattern` | `string \| string[]` | required | Glob pattern passed through to `glob()` |
| `base` | `string` | `'.'` | Base directory passed through to `glob()` |
| `frontmatter` | `string` | `undefined` | Path to a centralized frontmatter YAML/JSON file |
| `strategy` | `'file-wins' \| 'frontmatter-wins' \| 'frontmatter-only'` | `'file-wins'` | Merge strategy (see below) |
| `generateId` | `function` | `undefined` | Passed through to `glob()` |

Any additional `glob()` options are passed through transparently.

## Frontmatter File Formats

### Centralized file (`frontmatter` option)

Supports both nested and flat path formats, and both YAML and JSON. The formats can be mixed in a single file.

**Nested** — mirrors directory structure:
```yaml
guides:
  installation.md:
    title: Installation
    sidebar:
      order: 1
  getting-started.md:
    title: Getting Started
```

**Flat** — direct path keys:
```yaml
guides/installation.md:
  title: Installation
  sidebar:
    order: 1
```

**Detection rule**: A key is a filename if it ends in a content file extension (`.md`, `.mdx`, `.mdoc`). Otherwise it's treated as a directory name and recursed into.

### Per-directory files (auto-discovered)

Any `frontmatter.yml`, `frontmatter.yaml`, or `frontmatter.json` found in directories under `base` is automatically loaded. These use flat format only (keys are filenames, not paths):

```yaml
# docs/components/frontmatter.yml
README.md:
  title: Overview
  slug: components
  sidebar:
    order: 1
accordion.md:
  title: Accordion
  description: Styled expandable sections
```

No configuration flag needed — if the file exists, it's picked up. If you don't want per-directory frontmatter, don't create the files.

## Merge Cascade

Three layers, from broadest to most specific:

```
centralized file  →  per-directory file  →  in-file frontmatter
   (broadest)        (directory-scoped)       (most specific)
```

The `strategy` option controls which layer wins when keys conflict:

| Strategy | Behavior |
|----------|----------|
| `file-wins` (default) | `{ ...central, ...perDir, ...inFile }` — in-file frontmatter is the final word |
| `frontmatter-wins` | `{ ...inFile, ...perDir, ...central }` — centralized file overrides everything |
| `frontmatter-only` | `{ ...central, ...perDir }` — in-file frontmatter is ignored entirely |

**Nested object merge**: Deep merge for nested objects (e.g., `sidebar`), so `sidebar.order` from YAML doesn't clobber `sidebar.label` from the file when both exist.

## Architecture

### Approach: `parseData` Interceptor

The loader wraps Astro's `glob()` and intercepts the `LoaderContext.parseData` call. When `glob()` processes each entry, it calls `parseData` with the file's frontmatter. Our wrapper looks up the entry's path in the frontmatter map, merges per the strategy, then delegates to the real `parseData` for schema validation.

```
globFrontmatter(opts)
  │
  ├─ loadFrontmatterMap(opts.frontmatter, base)
  │    reads centralized YAML/JSON (if provided)
  │    scans for per-directory frontmatter.{yml,yaml,json}
  │    flattens nested → flat path map
  │    returns: Map<relativePath, frontmatterObject>
  │
  └─ returns Loader { name: 'glob-frontmatter', load(context) }
       │
       ├─ wraps context.parseData:
       │    1. look up entry id in frontmatter map
       │    2. merge per strategy (deep merge for nested objects)
       │    3. call original parseData with merged data
       │
       ├─ delegates to glob({ pattern, base, ...rest }).load(wrappedContext)
       │
       └─ watches frontmatter files for changes (dev mode)
            uses context.watcher to monitor frontmatter.{yml,yaml,json}
            triggers full reload on change
```

### Why this approach

- **Single pass**: No re-processing or double validation. Glob's digest caching works normally.
- **Public API**: `LoaderContext` and `parseData` are documented Astro APIs.
- **Minimal code**: The loader is a thin interception layer, not a reimplementation of glob.

### File watching (dev mode)

`context.watcher` (an FSWatcher) is available in dev mode. The loader watches:
- The centralized frontmatter file (if provided)
- All discovered per-directory frontmatter files

On change, trigger a full collection reload so entries pick up the updated metadata.

## Module Structure

```
astro-loader-glob-frontmatter/
├── src/
│   ├── index.ts              # globFrontmatter() — main export
│   ├── frontmatter-map.ts    # loadFrontmatterMap() — read/flatten/merge
│   └── merge.ts              # deep merge + strategy logic
├── test/
│   ├── frontmatter-map.test.ts
│   ├── merge.test.ts
│   └── loader.test.ts        # integration: mock LoaderContext
├── package.json
├── tsconfig.json
└── README.md
```

## Testing Strategy

- **Unit tests** for `frontmatter-map`: nested flattening, flat passthrough, mixed format, YAML vs JSON, missing files
- **Unit tests** for `merge`: all three strategies, deep merge behavior, edge cases (empty objects, null values)
- **Integration test** for the loader: mock `LoaderContext` and `glob()`, verify `parseData` receives merged data with correct precedence

## Open Questions

None — ready for implementation planning.
